use crate::state::State;

use image::{ImageBuffer, Rgb, RgbImage};
use imageproc::drawing::draw_filled_rect_mut;
use imageproc::rect::Rect;

// Global constants for the frame
const LINE_WIDTH: u32 = 2;
const CELL_SIZE: u32 = 20;
const CUBE_SIZE: u32 = 5; // 5x5 cube

const FACE_SIZE: u32 = CUBE_SIZE * CELL_SIZE + LINE_WIDTH;

const FACES_START_POS: [(u32, u32); 6] = [
    // Top face
    (FACE_SIZE, 0),
    // Left face
    (0, FACE_SIZE),
    // Center face
    (FACE_SIZE, FACE_SIZE),
    // Right face
    (2 * FACE_SIZE, FACE_SIZE),
    // Back face
    (3 * FACE_SIZE, FACE_SIZE),
    // Bottom face
    (FACE_SIZE, 2 * FACE_SIZE),
];
const FACE_0_X: u32 = FACES_START_POS[0].0;
const FACE_0_Y: u32 = FACES_START_POS[0].1;
const FACE_1_X: u32 = FACES_START_POS[1].0;
const FACE_1_Y: u32 = FACES_START_POS[1].1;
const FACE_2_X: u32 = FACES_START_POS[2].0;
const FACE_2_Y: u32 = FACES_START_POS[2].1;
const FACE_3_X: u32 = FACES_START_POS[3].0;
const FACE_3_Y: u32 = FACES_START_POS[3].1;
const FACE_4_X: u32 = FACES_START_POS[4].0;
const FACE_4_Y: u32 = FACES_START_POS[4].1;
const FACE_5_X: u32 = FACES_START_POS[5].0;
const FACE_5_Y: u32 = FACES_START_POS[5].1;

// Colors
const BLACK: Rgb<u8> = Rgb([0, 0, 0]);

const WHITE: Rgb<u8> = Rgb([255, 255, 255]);
const GREEN: Rgb<u8> = Rgb([0, 155, 72]);
const RED: Rgb<u8> = Rgb([185, 0, 0]);
const BLUE: Rgb<u8> = Rgb([0, 69, 173]);
const ORANGE: Rgb<u8> = Rgb([255, 89, 0]);
const YELLOW: Rgb<u8> = Rgb([255, 213, 0]);

fn draw_horizontal_line(img: &mut RgbImage, x: u32, y: u32, length: u32) {
    for i in 0..length {
        for j in 0..LINE_WIDTH {
            if x + i < img.width() && y + j < img.height() {
                img.put_pixel(x + i, y + j, BLACK);
            }
        }
    }
}

fn draw_vertical_line(img: &mut RgbImage, x: u32, y: u32, length: u32) {
    for i in 0..length {
        for j in 0..LINE_WIDTH {
            if x + j < img.width() && y + i < img.height() {
                img.put_pixel(x + j, y + i, BLACK);
            }
        }
    }
}

fn draw_face_frame(img: &mut RgbImage, start_x: u32, start_y: u32) {
    let face_size = CUBE_SIZE * CELL_SIZE;

    // Draw outer border
    draw_horizontal_line(img, start_x, start_y, face_size + LINE_WIDTH);
    draw_horizontal_line(img, start_x, start_y + face_size, face_size + LINE_WIDTH);
    draw_vertical_line(img, start_x, start_y, face_size + LINE_WIDTH);
    draw_vertical_line(img, start_x + face_size, start_y, face_size + LINE_WIDTH);

    // Draw internal grid lines
    for i in 1..CUBE_SIZE {
        // Horizontal internal lines
        draw_horizontal_line(
            img,
            start_x + LINE_WIDTH,
            start_y + i * CELL_SIZE,
            face_size - LINE_WIDTH,
        );
        // Vertical internal lines
        draw_vertical_line(
            img,
            start_x + i * CELL_SIZE,
            start_y + LINE_WIDTH,
            face_size - LINE_WIDTH,
        );
    }
}

// This function (and its callees) were pretty much completely generated by Claude.
fn draw_rubiks_cube_frame() -> RgbImage {
    // Calculate total image dimensions for the cross layout
    // Width: 4 faces wide (left face + center column + right face + extra space)
    // Height: 3 faces tall (top face + center row + bottom face)
    let img_width = 4 * FACE_SIZE;
    let img_height = 3 * FACE_SIZE;

    let mut img: RgbImage = ImageBuffer::from_pixel(img_width, img_height, Rgb([125, 125, 125]));

    // Draw the 6 faces of the cube net:
    for face_start_pos in FACES_START_POS {
        let (x, y) = face_start_pos;
        draw_face_frame(&mut img, x, y);
    }

    img
}

fn num_to_color(num: u8) -> Rgb<u8> {
    match num {
        0 => WHITE,
        1 => ORANGE,
        2 => GREEN,
        3 => RED,
        4 => BLUE,
        5 => YELLOW,
        _ => panic!("invalid number"),
    }
}

fn get_x_center_draw_position(index: usize) -> (usize, usize, usize) {
    if index >= 24 {
        panic!("invalid number");
    }

    let face_num = index / 4;

    let (x, y) = match index % 4 {
        0 => (1, 1),
        1 => (3, 1),
        2 => (3, 3),
        3 => (1, 3),
        _ => unreachable!(),
    };

    (face_num, x, y)
}
fn get_plus_center_draw_position(index: usize) -> (usize, usize, usize) {
    if index >= 24 {
        panic!("invalid number");
    }

    let face_num = index / 4;

    let (x, y) = match index % 4 {
        0 => (2, 1),
        1 => (3, 2),
        2 => (2, 3),
        3 => (1, 2),
        _ => unreachable!(),
    };

    (face_num, x, y)
}

fn draw_centers_on_image(state: &State, img: &mut RgbImage) {
    for (index, center) in state.centers_x.iter().enumerate() {
        let center_color = num_to_color(*center);
        let (face, x_tiles, y_tiles) = get_x_center_draw_position(index);
        let x = FACES_START_POS[face].0 + CELL_SIZE * x_tiles as u32 + LINE_WIDTH;
        let y = FACES_START_POS[face].1 + CELL_SIZE * y_tiles as u32 + LINE_WIDTH;
        let rect =
            Rect::at(x as i32, y as i32).of_size(CELL_SIZE - LINE_WIDTH, CELL_SIZE - LINE_WIDTH);
        draw_filled_rect_mut(img, rect, center_color);
    }

    for (index, center) in state.centers_plus.iter().enumerate() {
        let center_color = num_to_color(*center);
        let (face, x_tiles, y_tiles) = get_plus_center_draw_position(index);
        let x = FACES_START_POS[face].0 + CELL_SIZE * x_tiles as u32 + LINE_WIDTH;
        let y = FACES_START_POS[face].1 + CELL_SIZE * y_tiles as u32 + LINE_WIDTH;
        let rect =
            Rect::at(x as i32, y as i32).of_size(CELL_SIZE - LINE_WIDTH, CELL_SIZE - LINE_WIDTH);
        draw_filled_rect_mut(img, rect, center_color);
    }

    for face in 0..6 {
        let x = FACES_START_POS[face].0 + CELL_SIZE * 2 as u32 + LINE_WIDTH;
        let y = FACES_START_POS[face].1 + CELL_SIZE * 2 as u32 + LINE_WIDTH;
        let center_color = num_to_color(face as u8);
        let rect =
            Rect::at(x as i32, y as i32).of_size(CELL_SIZE - LINE_WIDTH, CELL_SIZE - LINE_WIDTH);
        draw_filled_rect_mut(img, rect, center_color);
    }
}

pub fn export_state_to_image(state: &State, file_path: &str) {
    let mut img = draw_rubiks_cube_frame();
    draw_centers_on_image(state, &mut img);
    img.save(file_path).expect("Failed to save state image");

    // println!("Rubik's cube frame saved as '{}'", file_path);
    // println!("Image dimensions: {}x{}", img.width(), img.height());
    // println!("Cell size: {}, Line width: {}", CELL_SIZE, LINE_WIDTH);
}
