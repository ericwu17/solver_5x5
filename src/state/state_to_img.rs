use crate::state::State;

use image::{ImageBuffer, Rgb, RgbImage};
use imageproc::drawing::draw_filled_rect_mut;
use imageproc::rect::Rect;

// Global constants for the frame
const LINE_WIDTH: u32 = 2;
const CELL_SIZE: u32 = 20;
const CUBE_SIZE: u32 = 5; // 5x5 cube

const FACE_SIZE: u32 = CUBE_SIZE * CELL_SIZE + LINE_WIDTH;

const FACES_START_POS: [(u32, u32); 6] = [
    // Top face
    (FACE_SIZE, 0),
    // Left face
    (0, FACE_SIZE),
    // Center face
    (FACE_SIZE, FACE_SIZE),
    // Right face
    (2 * FACE_SIZE, FACE_SIZE),
    // Back face
    (3 * FACE_SIZE, FACE_SIZE),
    // Bottom face
    (FACE_SIZE, 2 * FACE_SIZE),
];

// Colors
const BLACK: Rgb<u8> = Rgb([0, 0, 0]);

const WHITE: Rgb<u8> = Rgb([255, 255, 255]);
const GREEN: Rgb<u8> = Rgb([0, 155, 72]);
const RED: Rgb<u8> = Rgb([185, 0, 0]);
const BLUE: Rgb<u8> = Rgb([0, 69, 173]);
const ORANGE: Rgb<u8> = Rgb([255, 89, 0]);
const YELLOW: Rgb<u8> = Rgb([255, 213, 0]);

fn draw_horizontal_line(img: &mut RgbImage, x: u32, y: u32, length: u32) {
    for i in 0..length {
        for j in 0..LINE_WIDTH {
            if x + i < img.width() && y + j < img.height() {
                img.put_pixel(x + i, y + j, BLACK);
            }
        }
    }
}

fn draw_vertical_line(img: &mut RgbImage, x: u32, y: u32, length: u32) {
    for i in 0..length {
        for j in 0..LINE_WIDTH {
            if x + j < img.width() && y + i < img.height() {
                img.put_pixel(x + j, y + i, BLACK);
            }
        }
    }
}

fn draw_face_frame(img: &mut RgbImage, start_x: u32, start_y: u32) {
    let face_size = CUBE_SIZE * CELL_SIZE;

    // Draw outer border
    draw_horizontal_line(img, start_x, start_y, face_size + LINE_WIDTH);
    draw_horizontal_line(img, start_x, start_y + face_size, face_size + LINE_WIDTH);
    draw_vertical_line(img, start_x, start_y, face_size + LINE_WIDTH);
    draw_vertical_line(img, start_x + face_size, start_y, face_size + LINE_WIDTH);

    // Draw internal grid lines
    for i in 1..CUBE_SIZE {
        // Horizontal internal lines
        draw_horizontal_line(
            img,
            start_x + LINE_WIDTH,
            start_y + i * CELL_SIZE,
            face_size - LINE_WIDTH,
        );
        // Vertical internal lines
        draw_vertical_line(
            img,
            start_x + i * CELL_SIZE,
            start_y + LINE_WIDTH,
            face_size - LINE_WIDTH,
        );
    }
}

// This function (and its callees) were pretty much completely generated by Claude.
fn draw_rubiks_cube_frame() -> RgbImage {
    // Calculate total image dimensions for the cross layout
    // Width: 4 faces wide (left face + center column + right face + extra space)
    // Height: 3 faces tall (top face + center row + bottom face)
    let img_width = 4 * FACE_SIZE;
    let img_height = 3 * FACE_SIZE;

    let mut img: RgbImage = ImageBuffer::from_pixel(img_width, img_height, Rgb([125, 125, 125]));

    // Draw the 6 faces of the cube net:
    for face_start_pos in FACES_START_POS {
        let (x, y) = face_start_pos;
        draw_face_frame(&mut img, x, y);
    }

    img
}

fn num_to_color(num: u8) -> Rgb<u8> {
    match num {
        0 => WHITE,
        1 => ORANGE,
        2 => GREEN,
        3 => RED,
        4 => BLUE,
        5 => YELLOW,
        _ => panic!("invalid number"),
    }
}

fn get_x_center_draw_position(index: usize) -> (usize, usize, usize) {
    if index >= 24 {
        panic!("invalid number");
    }

    let face_num = index / 4;

    let (x, y) = match index % 4 {
        0 => (1, 1),
        1 => (3, 1),
        2 => (3, 3),
        3 => (1, 3),
        _ => unreachable!(),
    };

    (face_num, x, y)
}
fn get_plus_center_draw_position(index: usize) -> (usize, usize, usize) {
    if index >= 24 {
        panic!("invalid number");
    }

    let face_num = index / 4;

    let (x, y) = match index % 4 {
        0 => (2, 1),
        1 => (3, 2),
        2 => (2, 3),
        3 => (1, 2),
        _ => unreachable!(),
    };

    (face_num, x, y)
}

fn draw_tile(img: &mut RgbImage, face_x_y: (usize, usize, usize), color: u8) {
    let color = num_to_color(color);
    let (x, y) = get_location(face_x_y.0, face_x_y.1, face_x_y.2);
    let rect = Rect::at(x as i32, y as i32).of_size(CELL_SIZE - LINE_WIDTH, CELL_SIZE - LINE_WIDTH);
    draw_filled_rect_mut(img, rect, color);
}

fn get_location(face: usize, x_tiles: usize, y_tiles: usize) -> (u32, u32) {
    let x = FACES_START_POS[face].0 + CELL_SIZE * x_tiles as u32 + LINE_WIDTH;
    let y = FACES_START_POS[face].1 + CELL_SIZE * y_tiles as u32 + LINE_WIDTH;
    (x, y)
}

fn draw_centers_on_image(state: &State, img: &mut RgbImage) {
    for (index, center) in state.centers_x.iter().enumerate() {
        let (face, x_tiles, y_tiles) = get_x_center_draw_position(index);
        draw_tile(img, (face, x_tiles, y_tiles), *center);
    }

    for (index, center) in state.centers_plus.iter().enumerate() {
        let (face, x_tiles, y_tiles) = get_plus_center_draw_position(index);
        draw_tile(img, (face, x_tiles, y_tiles), *center);
    }

    for face in 0..6 {
        draw_tile(img, (face, 2, 2), face as u8);
    }
}

fn draw_corners_on_image(state: &State, img: &mut RgbImage) {
    let corners_colors = [
        [0, 1, 4],
        [0, 4, 3],
        [0, 3, 2],
        [0, 2, 1],
        [5, 1, 2],
        [5, 2, 3],
        [5, 3, 4],
        [5, 4, 1],
    ];
    let corner_tile_locations = [
        [(0, 0, 0), (1, 0, 0), (4, 4, 0)],
        [(0, 4, 0), (4, 0, 0), (3, 4, 0)],
        [(0, 4, 4), (3, 0, 0), (2, 4, 0)],
        [(0, 0, 4), (2, 0, 0), (1, 4, 0)],
        [(5, 0, 0), (1, 4, 4), (2, 0, 4)],
        [(5, 4, 0), (2, 4, 4), (3, 0, 4)],
        [(5, 4, 4), (3, 4, 4), (4, 0, 4)],
        [(5, 0, 4), (4, 4, 4), (1, 0, 4)],
    ];

    for (index, (corner_piece, piece_orientation)) in
        state.corners_perm.iter().zip(state.corners_ori).enumerate()
    {
        let mut c = corners_colors[*corner_piece as usize];

        if piece_orientation == 1 {
            (c[0], c[1], c[2]) = (c[1], c[2], c[0])
        } else if piece_orientation == 2 {
            (c[0], c[1], c[2]) = (c[2], c[0], c[1])
        }

        let locs = corner_tile_locations[index];
        for (loc, color) in locs.iter().zip(c.iter()) {
            draw_tile(img, *loc, *color);
        }
    }
}

fn draw_midges_on_image(state: &State, img: &mut RgbImage) {
    let midges_colors = [
        [0, 4],
        [0, 3],
        [0, 2],
        [0, 1],
        [2, 3],
        [2, 1],
        [4, 1],
        [4, 3],
        [5, 2],
        [5, 3],
        [5, 4],
        [5, 1],
    ];
    let midge_tile_locations = [
        [(0, 2, 0), (4, 2, 0)],
        [(0, 4, 2), (3, 2, 0)],
        [(0, 2, 4), (2, 2, 0)],
        [(0, 0, 2), (1, 2, 0)],
        [(2, 4, 2), (3, 0, 2)],
        [(2, 0, 2), (1, 4, 2)],
        [(4, 4, 2), (1, 0, 2)],
        [(4, 0, 2), (3, 4, 2)],
        [(5, 2, 0), (2, 2, 4)],
        [(5, 4, 2), (3, 2, 4)],
        [(5, 2, 4), (4, 2, 4)],
        [(5, 0, 2), (1, 2, 4)],
    ];

    for (index, (midge_piece, piece_orientation)) in
        state.midges_perm.iter().zip(state.midges_ori).enumerate()
    {
        let mut c = midges_colors[*midge_piece as usize];

        if piece_orientation == 1 {
            (c[0], c[1]) = (c[1], c[0])
        }

        let locs = midge_tile_locations[index];
        for (loc, color) in locs.iter().zip(c.iter()) {
            draw_tile(img, *loc, *color);
        }
    }
}

pub fn export_state_to_image(state: &State, file_path: &str) {
    let mut img = draw_rubiks_cube_frame();
    draw_centers_on_image(state, &mut img);
    draw_corners_on_image(state, &mut img);
    draw_midges_on_image(state, &mut img);
    img.save(file_path).expect("Failed to save state image");

    // println!("Rubik's cube frame saved as '{}'", file_path);
    // println!("Image dimensions: {}x{}", img.width(), img.height());
    // println!("Cell size: {}, Line width: {}", CELL_SIZE, LINE_WIDTH);
}
